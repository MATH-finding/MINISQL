#!/usr/bin/env python3
"""
索引解析测试文件
"""

import sys
import os

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from sql import SQLLexer, SQLParser
from sql.ast_nodes import CreateIndexStatement, DropIndexStatement
from sql.lexer import TokenType
from enum import auto


def test_lexer():
    """测试词法分析器"""
    print("=== 测试词法分析器 ===")

    test_sqls = [
        "CREATE INDEX idx_test ON students (id)",
        "CREATE UNIQUE INDEX idx_unique ON students (name)",
        "DROP INDEX idx_test",
    ]

    for sql in test_sqls:
        print(f"\n测试SQL: {sql}")
        try:
            lexer = SQLLexer(sql)
            tokens = lexer.tokenize()

            print("Token序列:")
            for i, token in enumerate(tokens):
                print(f"  [{i}] {token.type.name}: '{token.value}'")

        except Exception as e:
            print(f"词法分析错误: {e}")


def test_parser():
    """测试语法分析器"""
    print("\n=== 测试语法分析器 ===")

    test_cases = [
        {
            "sql": "CREATE INDEX idx_test ON students (id)",
            "expected": "CreateIndexStatement",
        },
        {
            "sql": "CREATE UNIQUE INDEX idx_unique ON students (name)",
            "expected": "CreateIndexStatement(unique=True)",
        },
        {"sql": "DROP INDEX idx_test", "expected": "DropIndexStatement"},
    ]

    for case in test_cases:
        sql = case["sql"]
        print(f"\n测试SQL: {sql}")
        print(f"期望结果: {case['expected']}")

        try:
            lexer = SQLLexer(sql)
            tokens = lexer.tokenize()

            parser = SQLParser(tokens)

            # 添加调试信息
            print(
                f"解析器当前token: {parser.current_token.type.name if parser.current_token else 'None'}"
            )

            ast = parser.parse()

            print(f"实际结果: {type(ast).__name__}")

            if isinstance(ast, CreateIndexStatement):
                print(f"  索引名: {ast.index_name}")
                print(f"  表名: {ast.table_name}")
                print(f"  列名: {ast.column_name}")
                print(f"  唯一索引: {ast.is_unique}")
            elif isinstance(ast, DropIndexStatement):
                print(f"  索引名: {ast.index_name}")

            print("✅ 解析成功")

        except Exception as e:
            print(f"❌ 解析错误: {e}")
            import traceback

            traceback.print_exc()


def test_integration():
    """测试完整流程"""
    print("\n=== 测试完整SQL执行流程 ===")

    try:
        from interface.database import SimpleDatabase

        db = SimpleDatabase("test_index.db")

        # 先创建表
        print("\n1. 创建测试表...")
        result = db.execute_sql(
            "CREATE TABLE test_table (id INTEGER PRIMARY KEY, name VARCHAR(50))"
        )
        print(f"创建表结果: {result}")

        # 尝试创建索引
        print("\n2. 创建索引...")
        result = db.execute_sql("CREATE INDEX idx_test_id ON test_table (id)")
        print(f"创建索引结果: {result}")

        # 尝试创建唯一索引
        print("\n3. 创建唯一索引...")
        result = db.execute_sql(
            "CREATE UNIQUE INDEX idx_test_name ON test_table (name)"
        )
        print(f"创建唯一索引结果: {result}")

        # 查看索引
        print("\n4. 查看索引...")
        indexes = db.list_indexes("test_table")
        print(f"索引列表: {indexes}")

        # 删除索引
        print("\n5. 删除索引...")
        result = db.execute_sql("DROP INDEX idx_test_id")
        print(f"删除索引结果: {result}")

        db.close()

        # 清理测试文件
        if os.path.exists("test_index.db"):
            os.remove("test_index.db")

    except Exception as e:
        print(f"❌ 完整流程测试失败: {e}")
        import traceback

        traceback.print_exc()


def test_join():
    """测试JOIN功能"""
    print("\n=== 测试JOIN功能 ===")
    try:
        from interface.database import SimpleDatabase
        db = SimpleDatabase("test_join.db")

        # 创建表
        db.execute_sql("CREATE TABLE students (id INTEGER PRIMARY KEY, name VARCHAR(20))")
        db.execute_sql("CREATE TABLE scores (id INTEGER PRIMARY KEY, student_id INTEGER, score INTEGER)")

        # 插入数据
        db.execute_sql("INSERT INTO students (id, name) VALUES (1, 'Alice'), (2, 'Bob')")
        db.execute_sql("INSERT INTO scores (id, student_id, score) VALUES (1, 1, 95), (2, 2, 88), (3, 1, 100)")

        # 测试JOIN
        print("\n1. INNER JOIN:")
        result = db.execute_sql(
            "SELECT students.id, students.name, scores.score FROM students JOIN scores ON students.id = scores.student_id"
        )
        print(f"JOIN原始返回: {result}")
        if not result.get('success', True):
            print(f"SQL执行失败: {result}")
        else:
            print(f"JOIN结果: {result['data']}")
        assert len(result['data']) == 3, "JOIN结果行数应为3"
        assert any(row['name'] == 'Alice' and row['score'] == 95 for row in result['data'])
        assert any(row['name'] == 'Alice' and row['score'] == 100 for row in result['data'])
        assert any(row['name'] == 'Bob' and row['score'] == 88 for row in result['data'])

        # 测试JOIN+WHERE
        print("\n2. JOIN + WHERE:")
        result = db.execute_sql(
            "SELECT students.name, scores.score FROM students JOIN scores ON students.id = scores.student_id WHERE scores.score > 90"
        )
        print(f"JOIN+WHERE结果: {result['data']}")
        assert all(row['score'] > 90 for row in result['data'])

        db.close()
        if os.path.exists("test_join.db"):
            os.remove("test_join.db")
        print("✅ JOIN功能测试通过")
    except Exception as e:
        print(f"❌ JOIN测试失败: {e}")
        import traceback
        traceback.print_exc()


def test_aggregate():
    """测试聚合函数功能"""
    print("\n=== 测试聚合函数功能 ===")
    try:
        from interface.database import SimpleDatabase
        db = SimpleDatabase("test_agg.db")

        # 创建表
        db.execute_sql("CREATE TABLE scores (id INTEGER PRIMARY KEY, student_id INTEGER, score INTEGER)")
        db.execute_sql("INSERT INTO scores (id, student_id, score) VALUES (1, 1, 95), (2, 2, 88), (3, 1, 100), (4, 2, 70)")

        # COUNT
        result = db.execute_sql("SELECT COUNT(*) FROM scores")
        print(f"COUNT结果: {result}")
        assert result['data'][0]['COUNT'] == 4

        # SUM
        result = db.execute_sql("SELECT SUM(score) FROM scores")
        print(f"SUM结果: {result}")
        assert result['data'][0]['SUM'] == 353

        # AVG
        result = db.execute_sql("SELECT AVG(score) FROM scores")
        print(f"AVG结果: {result}")
        assert abs(result['data'][0]['AVG'] - 88.25) < 1e-6

        # MIN
        result = db.execute_sql("SELECT MIN(score) FROM scores")
        print(f"MIN结果: {result}")
        assert result['data'][0]['MIN'] == 70

        # MAX
        result = db.execute_sql("SELECT MAX(score) FROM scores")
        print(f"MAX结果: {result}")
        assert result['data'][0]['MAX'] == 100

        db.close()
        if os.path.exists("test_agg.db"):
            os.remove("test_agg.db")
        print("✅ 聚合函数测试通过")
    except Exception as e:
        print(f"❌ 聚合函数测试失败: {e}")
        import traceback
        traceback.print_exc()


def test_unique_constraint():
    """测试UNIQUE约束"""
    print("\n=== 测试UNIQUE约束 ===")
    from interface.database import SimpleDatabase
    db = SimpleDatabase("test_unique.db")
    try:
        db.execute_sql("CREATE TABLE users (id INTEGER PRIMARY KEY, email VARCHAR(50) UNIQUE, name VARCHAR(20))")
        # 插入唯一email
        result = db.execute_sql("INSERT INTO users (id, email, name) VALUES (1, 'a@example.com', 'Alice')")
        print(f"插入1: {result}")
        result = db.execute_sql("INSERT INTO users (id, email, name) VALUES (2, 'b@example.com', 'Bob')")
        print(f"插入2: {result}")
        # 插入重复email应报错
        try:
            db.execute_sql("INSERT INTO users (id, email, name) VALUES (3, 'a@example.com', 'Charlie')")
            print("❌ 未检测到唯一约束冲突")
        except Exception as e:
            print(f"✅ 检测到唯一约束冲突: {e}")
        # 插入重复主键应报错
        try:
            db.execute_sql("INSERT INTO users (id, email, name) VALUES (1, 'c@example.com', 'Cathy')")
            print("❌ 未检测到主键冲突")
        except Exception as e:
            print(f"✅ 检测到主键冲突: {e}")
        # 插入重复email和主键都冲突
        try:
            db.execute_sql("INSERT INTO users (id, email, name) VALUES (2, 'b@example.com', 'Bobby')")
            print("❌ 未检测到主键和唯一约束冲突")
        except Exception as e:
            print(f"✅ 检测到主键或唯一约束冲突: {e}")
    finally:
        db.close()
        if os.path.exists("test_unique.db"):
            os.remove("test_unique.db")


def test_index_unique_constraint():
    """测试索引唯一性约束"""
    print("\n=== 测试索引唯一性约束 ===")
    from interface.database import SimpleDatabase
    db = SimpleDatabase("test_idx_unique.db")
    try:
        db.execute_sql("CREATE TABLE t (id INTEGER PRIMARY KEY, name VARCHAR(20))")
        db.execute_sql("CREATE UNIQUE INDEX idx_name ON t (name)")
        # 插入唯一name
        result = db.execute_sql("INSERT INTO t (id, name) VALUES (1, 'Alice')")
        print(f"插入1: {result}")
        result = db.execute_sql("INSERT INTO t (id, name) VALUES (2, 'Bob')")
        print(f"插入2: {result}")
        # 插入重复name应报错
        try:
            db.execute_sql("INSERT INTO t (id, name) VALUES (3, 'Alice')")
            print("❌ 未检测到索引唯一性冲突")
        except Exception as e:
            print(f"✅ 检测到索引唯一性冲突: {e}")
        # 再次插入已存在name
        try:
            db.execute_sql("INSERT INTO t (id, name) VALUES (4, 'Bob')")
            print("❌ 未检测到索引唯一性冲突2")
        except Exception as e:
            print(f"✅ 检测到索引唯一性冲突2: {e}")
        # 插入主键冲突
        try:
            db.execute_sql("INSERT INTO t (id, name) VALUES (1, 'Charlie')")
            print("❌ 未检测到主键冲突")
        except Exception as e:
            print(f"✅ 检测到主键冲突: {e}")
    finally:
        db.close()
        if os.path.exists("test_idx_unique.db"):
            os.remove("test_idx_unique.db")


def test_default_check_foreign():
    """测试DEFAULT、CHECK、FOREIGN KEY约束"""
    print("\n=== 测试DEFAULT、CHECK、FOREIGN KEY约束 ===")
    from interface.database import SimpleDatabase
    db = SimpleDatabase("test_constraint.db")
    try:
        # 测试DEFAULT
        db.execute_sql("CREATE TABLE t1 (id INTEGER PRIMARY KEY, name VARCHAR(20) DEFAULT 'unknown', age INTEGER DEFAULT 18)")
        result = db.execute_sql("INSERT INTO t1 (id) VALUES (1)")
        print(f"DEFAULT插入: {result}")
        res = db.execute_sql("SELECT * FROM t1")
        print(f"DEFAULT结果: {res['data']}")
        assert res['data'][0]['name'] == 'unknown' and res['data'][0]['age'] == 18

        """全面测试 CHECK 约束"""
        db.execute_sql("""
            CREATE TABLE products (
                id INTEGER PRIMARY KEY,
                name TEXT,
                price REAL CHECK (price > 0),
                stock INTEGER CHECK (stock >= 0)
            )
        """)
        print("    SETUP: 'products' 表创建成功.")

        # --- 成功场景 ---
        print("\n  --- 测试成功场景 ---")
        db.execute_sql("INSERT INTO products VALUES (1, 'Apple', 1.5, 100)")
        print("    ✅ PASSED: 成功插入完全合法的数据。")
        db.execute_sql("INSERT INTO products VALUES (2, 'Banana', 0.8, 0)")
        print("    ✅ PASSED: 成功插入边界值 (stock = 0)。")

        # --- 失败场景 ---
        print("\n  --- 测试失败场景 (预期会抛出异常) ---")
        try:
            db.execute_sql("INSERT INTO products VALUES (3, 'Lemon', -1, 50)")
            raise AssertionError("❌ FAILED: 未能阻止插入不满足 CHECK 的负数价格。")
        except Exception as e:
            print(f"    ✅ PASSED: 成功阻止插入负数价格。错误: {type(e).__name__}")

        try:
            db.execute_sql("INSERT INTO products VALUES (4, 'Orange', 2.0, -10)")
            raise AssertionError("❌ FAILED: 未能阻止插入不满足 CHECK 的负数库存。")
        except Exception as e:
            print(f"    ✅ PASSED: 成功阻止插入负数库存。错误: {type(e).__name__}")
            
        try:
            db.execute_sql("UPDATE products SET price = 0 WHERE id = 1")
            raise AssertionError("❌ FAILED: UPDATE 操作未能触发 CHECK 约束。")
        except Exception as e:
            print(f"    ✅ PASSED: UPDATE 操作成功触发 CHECK 约束。错误: {type(e).__name__}")


        """全面测试 FOREIGN KEY 约束"""
        # --- Setup ---
        db.execute_sql("CREATE TABLE categories (id INTEGER PRIMARY KEY, name TEXT NOT NULL UNIQUE)")
        db.execute_sql("""
            CREATE TABLE products_fk (
                id INTEGER PRIMARY KEY,
                name TEXT,
                category_id INTEGER,
                FOREIGN KEY (category_id) REFERENCES categories(id)
            )
        """)
        db.execute_sql("INSERT INTO categories VALUES (10, 'Fruits')")
        db.execute_sql("INSERT INTO categories VALUES (20, 'Vegetables')")
        print("    SETUP: 'categories' 和 'products_fk' 表创建成功并已填充主表数据。")

        # --- 成功场景 ---
        print("\n  --- 测试成功场景 ---")
        db.execute_sql("INSERT INTO products_fk VALUES (101, 'Apple', 10)")
        print("    ✅ PASSED: 成功插入合法的外键引用。")
        
        # 根据SQL标准，外键为NULL是允许的
        db.execute_sql("INSERT INTO products_fk VALUES (102, 'Orphan Product', NULL)")
        print("    ✅ PASSED: 成功插入外键为 NULL 的记录。")
        
        # --- 失败场景 ---
        print("\n  --- 测试失败场景 (预期会抛出异常) ---")
        try:
            db.execute_sql("INSERT INTO products_fk VALUES (103, 'Cabbage', 99)")
            raise AssertionError("❌ FAILED: 未能阻止插入不存在的外键值。")
        except Exception as e:
            print(f"    ✅ PASSED: 成功阻止插入不存在的外键。错误: {type(e).__name__}")
            
        try:
            db.execute_sql("UPDATE products_fk SET category_id = 88 WHERE id = 101")
            raise AssertionError("❌ FAILED: UPDATE 操作未能触发外键约束。")
        except Exception as e:
            print(f"    ✅ PASSED: UPDATE 操作成功触发外键约束。错误: {type(e).__name__}")

        # 这是一个更高级的测试，测试当父表记录被删除时，是否能保护子表数据
        # 注意：这依赖于你的 DELETE 实现是否检查了外键引用
        try:
            db.execute_sql("DELETE FROM categories WHERE id = 10")
            raise AssertionError("❌ FAILED: 未能阻止删除被引用的父表记录。")
        except Exception as e:
            print(f"    ✅ PASSED: 成功阻止删除被引用的父表记录。错误: {type(e).__name__}")

    finally:
        db.close()
        if os.path.exists("test_constraint.db"):
            os.remove("test_constraint.db")


def test_view():
    """测试视图功能"""
    print("\n=== 测试视图功能 ===")
    from interface.database import SimpleDatabase
    db = SimpleDatabase("test_view.db")
    try:
        # 创建基础表并插入数据，作为视图的数据来源
        db.execute_sql("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)")
        db.execute_sql("INSERT INTO users VALUES (1, 'Alice', 20)")
        db.execute_sql("INSERT INTO users VALUES (2, 'Bob', 17)")
        db.execute_sql("INSERT INTO users VALUES (3, 'Carol', 25)")

        # 创建一个筛选出成年用户(>=18)且只保留部分列(id, name)的视图
        db.execute_sql("CREATE VIEW adult_users AS SELECT id, name FROM users WHERE age >= 18")
        print("    创建视图 adult_users 成功")
        # 直接查询视图，验证其是否能正确返回过滤后的行与列
        result = db.execute_sql("SELECT * FROM adult_users")
        print("DEBUG: 视图查询原始返回：", result)
        print(f"    查询视图结果: {result['data']}")
        # 这里的断言被注释掉，保留打印结果用于手动检查
        # assert len(result['data']) == 2
        # assert any(row['name'] == 'Alice' for row in result['data'])
        # assert any(row['name'] == 'Carol' for row in result['data'])

        # 基于已存在视图再创建嵌套视图，验证视图可被进一步组合与筛选
        db.execute_sql("CREATE VIEW alice_only AS SELECT * FROM adult_users WHERE name = 'Alice'")
        # 查询嵌套视图应仅包含 name 为 'Alice' 的记录
        result2 = db.execute_sql("SELECT * FROM alice_only")
        print(f"    查询嵌套视图结果: {result2['data']}")
        # assert len(result2['data']) == 1 and result2['data'][0]['name'] == 'Alice'

        # 删除视图并验证删除后的访问会抛出异常
        db.execute_sql("DROP VIEW alice_only")
        res = db.execute_sql("SELECT * FROM alice_only")
        assert not res.get("success", True)
        print(f"    ✅ 查询已删除视图返回失败: {res.get('error')}")

        db.execute_sql("DROP VIEW adult_users")  # 加回这一行
        res2 = db.execute_sql("SELECT * FROM adult_users")
        assert not res2.get("success", True)
        print(f"    ✅ 查询已删除视图返回失败: {res2.get('error')}")
    finally:
        # 关闭数据库连接并清理测试文件
        db.close()
        if os.path.exists("test_view.db"):
            os.remove("test_view.db")


def main():
    print("🧪 索引解析测试工具")
    print("=" * 40)

    test_lexer()
    test_parser()
    test_integration()
    test_join()  # 新增JOIN测试
    test_aggregate()  # 新增聚合函数测试
    test_unique_constraint()  # 新增UNIQUE约束测试
    test_index_unique_constraint()  # 新增索引唯一性约束测试
    test_default_check_foreign()  # 新增DEFAULT、CHECK、FOREIGN KEY测试
    test_view()  # 新增视图测试

    print("\n✅ 测试完成")


if __name__ == "__main__":
    main()
